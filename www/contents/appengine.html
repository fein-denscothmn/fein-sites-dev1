<!DOCTYPE html>
<!-- ●ここから人間用のヘッダー● -->
<html lang="ja">

<head>
 <link rel="manifest" href="/manifest.json">

 <script>
  if ('serviceWorker' in navigator) {
   navigator.serviceWorker.register('/service-worker.js')
    .then(registration => {
     console.log('ServiceWorker registration successful with scope: ', registration.scope);
    })
    .catch(error => {
     console.log('ServiceWorker registration failed: ', error);
    });
  }
 </script>

 <!-- Google tag (gtag.js) -->
 <script async src="https://www.googletagmanager.com/gtag/js?id=G-827JM6N5CS"></script>
 <script>
  window.dataLayer = window.dataLayer || [];
  function gtag() { dataLayer.push(arguments); }
  gtag('js', new Date());

  gtag('config', 'G-827JM6N5CS');
 </script>

 <!-- Microsoft tag -->
 <script>
  (function (c, l, a, r, i, t, y) {
   c[a] = c[a] || function () { (c[a].q = c[a].q || []).push(arguments) };
   t = l.createElement(r); t.async = 1; t.src = "https://www.clarity.ms/tag/" + i;
   y = l.getElementsByTagName(r)[0]; y.parentNode.insertBefore(t, y);
  })(window, document, "clarity", "script", "obazqypsh8");
 </script>

 <meta charset="UTF-8">


 <!--基本のメタタグ-->
 <meta name="description" content="個人サイトを作ろうとすると障害になるのが、業者が強制的に挿入してくる広告です。そんなものを使わずとも、Google App Engineなら広告なしで作れます。">
 <meta name="keywords" content="個人サイト, Google App Engine, 広告なし">
 <meta name="robots" content="index, follow">
 <meta property="og:title" content="Google App Engineで広告なしサイト作成">
 <meta property="og:description"
  content="個人サイトを作ろうとすると障害になるのが、業者が強制的に挿入してくる広告です。そんなものを使わずとも、Google App Engineなら広告なしで作れます。">
 <meta property="og:image" content="../image/アナザーエデンのバディ_ピスケ.png">
 <meta property="og:url" content="https://fein-sites-dev1.ew.r.appspot.com/contents/appengine.html">

 <!--検索ヒット時のアイコン-->
 <script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "Organization",
  "name": "Google App Engineで広告なしサイト作成",
  "url": "https://fein-sites-dev1.ew.r.appspot.com/contents/appengine.html",
  "logo": "https://fein-sites-dev1.ew.r.appspot.com/image/barracuda.jpeg"
}
</script>

 <!--レスポンシブデザイン-->
 <meta name="viewport" content="width=device-width, initial-scale=1.0">

 <!--CSS-->
 <link rel="stylesheet" type="text/css" href="/css/style.css">
 <link rel="stylesheet" type="text/css" href="/css/header.css">
 <link rel="stylesheet" type="text/css" href="/css/footer.css">
 <link rel="stylesheet" type="text/css" href="../css/menu.css">
 <link rel="stylesheet" type="text/css" href="../css/feinpan.css">
 <link rel="stylesheet" type="text/css" href="../css/feinheadline1.css">
 <link rel="stylesheet" type="text/css" href="../css/flower.css">
 <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/themes/prism-tomorrow.min.css">
 <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">

 <!--JavaScript-->
 <script src="../script/underline.js"></script>
 <script src="../script/feinfade.js"></script>
 <script src="../script/feinScroll.js"></script>
 <!-- gsapの読み込み -->
 <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.7.1/gsap.min.js"></script>
 <!-- prismの読み込み -->
 <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/prism.min.js"></script>
 <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/components/prism-bash.min.js"></script>
 <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/components/prism-python.min.js"></script>
 <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/components/prism-yaml.min.js"></script>

 <!-- google fonts -->
 <link rel="preconnect" href="https://fonts.googleapis.com">
 <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
 <link
  href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@100..900&family=Lato:ital,wght@0,100;0,300;0,400;0,700;0,900;1,100;1,300;1,400;1,700;1,900&display=swap"
  rel="stylesheet">

 <!--ページタイトル-->
 <title>Google App Engineで広告なしサイト作成</title>

 <!--ASノーナのファビコン-->
 <link rel="icon" sizes="32x32" href="../favicon.ico" type="image/x-icon">
</head>

<body>

 <nav class="den_nav">
  <ul>
   <li><a href="https://fein-sites-dev1.ew.r.appspot.com/"><img src="/menu/mspass.png" alt="このサイトのシンボルマーク"
      class="feinhome"></a></li>
   <li><a href="/" class="animated-link">ホーム</a></li>
   <li><a href="/another-eden/anaden_sitemap.html" class="animated-link">アナザーエデン</a></li>
   <li><a href="/fish/fish_sitemap.html" class="animated-link">アウトドアのエリア</a></li>
   <li><a href="/contents/site_create.html" class="animated-link">個人サイト制作</a></li>
   <li><a href="/contents/protect.html" class="animated-link">AI学習を防ぐ工夫</a></li>
   <li><a href="/contents/rss.html" class="animated-link">更新のお知らせ</a></li>
  </ul>
 </nav>

 <!--レスポンシブデザイン-->
 <div class="feincontainer">

  <!--パンくずリスト-->
  <div>
   <ol class="breadcrumb">
    <li class="breadcrumb-item"><a href="/">Home（グラスタの場所一覧表〜入手範囲別〜）</a></li>
    <li class="breadcrumb-item"><a href="site_create.html">個人サイト制作：サイトマップ</a></li>
    <li class="breadcrumb-item active" aria-current="page">Google App Engineで広告なしサイト作成</li>
   </ol>
  </div>

  <div class="search-container">
   <script async src="https://cse.google.com/cse.js?cx=07df877a5cdad4ece">
   </script>
   <div class="gcse-searchbox-only"></div>
  </div>

  <!-- ハンバーガーメニュー -->
  <div class="fden-hamburger-menu">
   <button class="fden-hamburger-button" id="fden-hamburger-button" onclick="toggleMenu()">☰ メニューを開く ▼</button>
   <div class="fden-menu" id="fden-menu">
    <!-- メニュー内容は外部ファイルから読み込む -->
    <div id="fden-menu-content"></div>
   </div>
  </div>
  <script src="../script/menu.js"></script>
  <!-- ハンバーガーメニューここまで -->

  <!--サイトタイトル-->
  <div class="header-frame">
   <div class="header-container">
    <img src="../image/cloudsitetitle.jpg" alt="fein's personal site" class="header-image">
    <div class="header-text">
     <a href="https://fein-sites-dev1.ew.r.appspot.com/">fein's personal site</a>
    </div>
   </div>
  </div>

  <div class="spacer"></div>
  <button id="generate-headings" data-open-text="Google App Engineで広告なしサイト作成の目次を開く ▼"
   data-close-text="Google App Engineで広告なしサイト作成の目次を閉じる ▲">Google App Engineで広告なしサイト作成の目次を開く
   ▼</button><!--目次の自動生成-->

  <div class="spacer"></div>
  <p><a href="site_create.html">個人サイト制作：サイトマップへ戻る</a></p>

  <!-- ●人間用のヘッダーここまで。直下でコンテンツ開始● -->

  <h1 class="background-waveimage-heading"><span>Google App Engineで広告なしサイト作成</span></h1>
  <p>Google App Engineは、あなたのWebサイトやアプリをインターネット上に簡単に公開できるサービス。<br>
   プログラムを書いたら、Googleのサーバーで動かせるようにしてくれます。<br>
   個人サイトを作り場合、大きく分けて次の2つが考えられます。</p>

  <ol>
   <li>既存のホームページ作成サービスを使う</li>
   <li>HTMLを初めとするソースコードが書ける場合、クラウドを使う選択肢が出てくる</li>
  </ol>

  <p>ここでお話しするのは、主に後者です。</p>

  <h2>Google App Engineの仕組み</h2>
  <div class="flowerclearfix">
   <div class="flowerfade-out">
    <img src="/flower1/forest1(20).jpg" alt="フェードアウト効果の草花写真">
   </div>
   <p>上記でGoogleのサーバーと書いたけど、App Engineはサーバーとはまた少し違うんですよね。</p>

   <dl>
    <dt>App Engineアプリの設定ファイル</dt>
    <dd>App Engineを使うアプリには、app.yamlという設定ファイルが必要です。<br>
     これはアプリの動作を指示する重要なファイルです。</dd>

    <dt>runtimeエントリ</dt>
    <dd>app.yamlファイルには、少なくとも「runtime（実行環境）」という設定が必要です。<br>
     これはどのプログラミング言語を使うかを指定します。</dd>

    <dt>各サービスの設定</dt>
    <dd>アプリが複数の機能（サービス）を持っている場合、各サービスに専用のapp.yamlファイルが必要です。<br>
     これがそのサービスの設定を行います。</dd>

    <dt>defaultサービスの設定</dt>
    <dd>まず最初にアプリの「default（デフォルト）サービス」に対してapp.yamlファイルを作成します。<br>
     その後、追加のサービスに対してもそれぞれapp.yamlファイルを作成します。</dd>
   </dl>
  </div>

  <h3>runtime（実行環境）</h3>
  <div class="flowerclearfix">
   <div class="flowerfade-out">
    <img src="/flower1/forest1(21).jpg" alt="フェードアウト効果の草花写真">
   </div>
   <p>アプリケーションを実行するために必要な特定の設定や環境のことです。<br>
    これには使うプログラミング言語やフレームワークが含まれます。</p>
   <p>上述しましたが、App Engineは通常のサーバーとは少し違います。<br>
    普通のサーバーは自分で設定や管理をする必要がありますが、App EngineはGoogleが提供する「マネージドサービス」と呼ばれるもので、サーバーの設定や管理をGoogleが行います。<br>
    ユーザーはアプリケーションのコードと設定ファイルを用意するだけで、App Engineが自動的にリソースを割り当ててアプリケーションを実行してくれます。</p>

   <p>簡単に言うと、runtimeを使って「私はこの言語（例えばPythonやJava）でアプリを動かします」とApp Engineに教えることで、App Engineがその言語に合った環境を準備してくれるのです。</p>
  </div>

  <h3>Pythonランタイムでウェブサイトをホスティングする</h3>
  <div class="flowerclearfix">
   <div class="flowerfade-out">
    <img src="/flower1/forest1(22).jpg" alt="フェードアウト効果の草花写真">
   </div>
   <p>App Engine では、pythonランタイムを指定しても静的ウェブサイト（HTMLファイル、CSS、JavaScriptなど）をホスティングできます。<br>
    私のWebサイトはこの仕組みを使っています。<br>
    App Engineは柔軟なアプリケーションホスティングプラットフォームと表現することも可能ですよね。</p>

   <dl>
    <dt>静的ファイルのホスティング</dt>
    <dd>App Engine は、静的ファイル（HTML、CSS、JavaScript、画像など）を効率的に配信する機能があります。</dd>
    <dd>app.yaml ファイルで静的ファイルのディレクトリを指定することで、これらのファイルをアプリの一部として公開できます。</dd>

    <dt>ディフォルトのサービス提供</dt>
    <dd>Pythonランタイムを指定しても、特に Pythonコードが含まれていない場合、静的ファイルをそのまま提供できます。</dd>
    <dd>つまり、Pythonランタイムを使っているという指定は、特定のサーバーサイドコードを実行するためのものであり、静的コンテンツの提供に影響を与えません。</dd>
   </dl>
  </div>

  <p>ここで、シンプルな app.yaml の例を示してみましょう。</p>

  <div class="code-container">
   <pre><code class="language-yaml">
runtime: python
handlers:
- url: /static
static_dir: static/
- url: /.*
script: auto

</code></pre>
  </div>

  <p>この構成では、/static ディレクトリ内のファイルを静的コンテンツとして配信し、その他のURLに対しては自動的にPythonスクリプトを実行します。<br>
   このようにして、App Engine を使用して静的ウェブサイトを簡単にホスティングすることが可能です。</p>

  <div class="flowerclearfix">
   <div class="flowerfade-out">
    <img src="/flower1/forest1(23).jpg" alt="フェードアウト効果の草花写真">
   </div>
   <p>このサイトの場合、Pythonランタイムを指定しているものの、実際には静的なファイルだけを公開している状態です。<br>
    Pythonのコードが実行されていないため ─ 例外はあるけれど ─、Pythonランタイムの設定は単に環境として存在しているだけとなっているんですよね。<br>
    つまり、App EngineではPythonランタイムを指定することで、必要な場合にPythonコードを実行するための環境が用意されますが、実際に提供されているのは静的なファイルということになります。<br>
    この設定の利点は、将来的に動的なPythonコードを追加したい場合にすぐ対応できる柔軟性がある点です。</p>
  </div>

  <h3>App Engine の静的ファイル配信機能</h3>
  <div class="flowerclearfix">
   <div class="flowerfade-out">
    <img src="/flower1/forest1(25).jpg" alt="フェードアウト効果の草花写真">
   </div>
   <p>App Engine は静的ファイルを効率的かつ安全に配信することができるのです。</p>

   <dl>
    <dt>キャッシュ機能</dt>
    <dd>静的ファイルは一度リクエストされると、App Engine がそれをキャッシュに保存します。<br>
     次回のリクエスト時には、キャッシュから高速に配信するため、ロード時間が短縮されます。</dd>

    <dt>圧縮</dt>
    <dd>App Engine は静的ファイルを自動的に圧縮し、配信の効率を上げます。<br>
     ユーザーのデータ転送量が減り、ページの読み込み速度が向上します。</dd>

    <dt>CDN（コンテンツ配信ネットワーク）統合</dt>
    <dd>App Engine は Google の広範なCDNネットワークを活用して、世界中のユーザーに対して低遅延でファイルを配信します。<br>
     地理的に遠くにいるユーザーにも高速にコンテンツを提供できます。</dd>

    <dt>セキュリティ</dt>
    <dd>静的ファイルはHTTPS（SSL/TLS）で配信されるため、データの盗聴や改ざんから守られます。</dd>

    <dt>自動スケーリング</dt>
    <dd>トラフィックが急増してもApp Engine が自動的にリソースをスケーリングして対応します。<br>
     大量のアクセスにも耐えられるようになります。</dd>

    <dt>静的ファイルのマッピング</dt>
    <dd>app.yaml ファイルで静的ファイルのディレクトリを指定することで、特定のURLパスにファイルを簡単にマッピングできます。<br>
     たとえば、 /static フォルダ内のすべてのファイルを /static/* のURLでアクセスできるように設定することができます。</dd>
   </dl>
  </div>

  <h2>app.yaml構文の詳説</h2>
  <div class="flowerclearfix">
   <div class="flowerfade-out">
    <img src="/flower1/forest1(296).jpg" alt="フェードアウト効果の草花写真">
   </div>
   <p>app.yamlの構文では、URLやファイルパスのパターンを記述する際に、POSIX拡張正規表現を使用するので、使いやすい文字列パターンの指定が可能です。<br>
    また、グループ化したパターンを後で参照する機能や、Perl拡張の特殊文字（例:\wや\d）もサポートされています。<br>
    要するに、より柔軟で詳細なパターンマッチングができるということです。</p>

   <p>ここで、yamlの事例を見てみましょう。</p>
  </div>


  <div class="code-container">
   <pre><code class="language-yaml">
runtime: python312
instance_class: F2
env_variables:
BUCKET_NAME: "example-gcs-bucket"
handlers:
# Matches requests to /images/... to files in static/images/...
- url: /images
static_dir: static/images
- url: /.*
secure: always
redirect_http_response_code: 301
script: auto

</code></pre>
  </div>

  <p><a href="https://cloud.google.com/appengine/docs/standard/reference/app-yaml?hl=ja&tab=python">App Engine
    app.yaml リファレンス</a>も参考にして頂けるとよろしいかと。<br>
   このyaml構文を詳しく説明すると、次のようになります。</p>

  <div class="code-container">
   <pre><code class="language-yaml">
# アプリケーションのランタイム環境を指定します。この場合は Python 3.12 を使用します。
runtime: python312

# インスタンスのクラスを指定します。F2 は、適度なパフォーマンスとリソースを提供するクラスです。
instance_class: F2

# 環境変数を指定します。アプリケーション内で使用する設定値を管理します。
env_variables:
# Google Cloud Storage バケットの名前を指定します。
BUCKET_NAME: "example-gcs-bucket"

# リクエストを処理するためのハンドラーを定義します。
handlers:
# /images で始まるURLパスに対して、静的ディレクトリ static/images 内のファイルをマッピングします。
# 例えば、/images/logo.png は static/images/logo.png にマッピングされます。
- url: /images
static_dir: static/images

# すべてのリクエストに一致させます。/.* はすべての URL パスにマッチする正規表現です。
- url: /.*
# HTTP を HTTPS にリダイレクトします。secure: always は常に HTTPS を使用することを示します。
secure: always
# HTTP リダイレクトのレスポンスコードを 301（永久的なリダイレクト）に設定します。
redirect_http_response_code: 301
# スクリプト自動設定を使用します。script: auto は自動的に適切なスクリプトを選択することを示します。
script: auto

</code></pre>
  </div>

  <p>yaml構文を全て学ぼうとするとキリがないでしょう。<br>
   しかしApp Engineを使う場合、Googleの公式ドキュメントに記載されている範囲内の情報くらいは把握しておくとラクです。</p>

  <h5>app_engine_apis</h5>
  <div class="flowerclearfix">
   <div class="flowerfade-out">
    <img src="/flower1/forest1(297).jpg" alt="フェードアウト効果の草花写真">
   </div>
   <p><span class="small-orange-text">※必ずしも設定する必要はありません。</span></p>
   <p>これはApp Engineの最新の環境で昔からあるサービスを使いたい場合、この設定を「true」にする、という意味です。<br>
    App Engineの中に、「App Engine APIs」という、アプリが利用するためのさまざまな機能やサービスを含むAPIがあります。<br>
    2025年1月現在、App Engineの最新のランタイム環境は第2世代ランタイムです。─ ランタイム：アプリケーションが実行される環境のこと ─
    一方、以前からある複数の機能やサービスをまとめて提供する従来のバンドルサービスは、第1世代から存在しています。<br>
    このフィールドを「true」に設定することで、従来のバンドルサービスを第2世代ランタイムで使えるということです。</p>

   <p>App Engineの従来のバンドルサービスには、次のような機能やツールが含まれています。</p>
  </div>

  <dl>
   <dt>Memcache</dt>
   <dd>高速のキャッシュサービス。アプリのパフォーマンス向上に役立ちます。</dd>

   <dt>Mail</dt>
   <dd>アプリケーションからメールを送信するためのサービス。</dd>

   <dt>XMPP</dt>
   <dd>メッセージング用プロトコルを使って、リアルタイム通信を可能にするサービス。</dd>

   <dt>Blobstore</dt>
   <dd>大量のデータ（画像や動画など）を保存するためのサービス。</dd>

   <dt>Users</dt>
   <dd>ユーザー認証を簡単に行うためのサービス。</dd>
  </dl>

  <p>これらのサービスはアプリケーション開発のさまざまなニーズに対応するためのものですね。<br>
   第1世代からずっと使われている定番の機能です。<br>
   第2世代ランタイムでもこれらを使いたい場合には、上記の説明のように、yamlファイルで設定を「true」にする必要があります。</p>

  <h5>build_env_variables</h5>
  <div class="flowerclearfix">
   <div class="flowerfade-out">
    <img src="/flower1/forest1(298).jpg" alt="フェードアウト効果の草花写真">
   </div>
   <p><span class="small-orange-text">※必ずしも設定する必要はありません。</span></p>
   <p>この build_env_variables を使って、ビルド時に必要な情報を整理し、アプリケーションを正しく動作させる設定を行います。<br>
    ビルド環境変数とはソフトウェアの構築 ─ しばしば「ビルド」と呼ばれる ─ 中に使用される設定情報です。<br>
    例えばデータベースの接続情報やAPIキーなど、ビルド時に必要な情報をここで指定します。<br>
    buildpacksはプログラムをビルドして実行可能な形式に変換するツールであり、ソースコードを受け取って、それを実行可能なアプリケーションにします。</p>

   <p>つまり、app.yamlファイルの中で build_env_variables を使ってビルド環境変数を定義するというのは、ビルド中に必要な情報を指定しておくということです。<br>
    少し事例を見てみましょう。</p>
  </div>


  <div class="code-container">
   <pre><code class="language-yaml">
build_env_variables:
DATABASE_URL: "mysql://user:password@localhost:3306/mydatabase"
API_KEY: "your-api-key"

</code></pre>
  </div>

  <p>こうやって書くと、ビルド中に DATABASE_URL や API_KEY といった情報が使用されます。</p>

  <h5>default_expiration</h5>
  <div class="flowerclearfix">
   <div class="flowerfade-out">
    <img src="/flower1/forest1(300).jpg" alt="フェードアウト効果の草花写真">
   </div>
   <p><span class="small-orange-text">※必ずしも設定する必要はありません。</span></p>
   <p>アプリケーションにある静的ファイル ─ 画像、CSS、JavaScriptなど ─ のキャッシュ期間を設定し、読み込み速度を改善するための設定です。<br>
    キャッシュ期間とは、ファイルがブラウザやサーバーに保存される期間のことです。<br>
    この期間中に再度そのファイルにアクセスすると、サーバーからではなくキャッシュから読み込まれます。<br>
    するとWebコンテンツの表示が早くなります。</p>

   <p>キャッシュ期間は、次のような単位の文字列を付け、数値と組み合わせて設定します。</p>
  </div>


  <ul>
   <li><strong>d</strong> は日数（days）を表します。</li>
   <li><strong>h</strong> は時間（hours）を表します。</li>
   <li><strong>m</strong> は分（minutes）を表します。</li>
   <li><strong>s</strong> は秒（seconds）を表します。</li>
  </ul>

  <p>例えば「4d 5h」と指定すると、そのファイルのキャッシュ有効期限は最初にリクエストされてから4日と5時間後になります。<br>
   次に、app.yamlファイルへdefault_expirationを設定した例を示します。</p>

  <div class="code-container">
   <pre><code class="language-yaml">
runtime: python312
default_expiration: "4d 5h"
handlers:
# ...以下略

</code></pre>
  </div>

  <p>この設定により、静的ファイルのキャッシュ有効期限が4日と5時間に設定されます。<br>
   もしdefault_expirationを省略した場合、本番環境ではサーバーが自動的に有効期限を10分に設定します。</p>

  <h5>entrypoint</h5>
  <div class="flowerclearfix">
   <div class="flowerfade-out">
    <img src="/flower1/forest1(299).jpg" alt="フェードアウト効果の草花写真">
   </div>
   <p><span class="small-orange-text">※必ずしも設定する必要はありません。</span></p>
   <p>アプリがどうやって起動するかを細かくコントロールできます。<br>
    アプリがHTTPリクエスト（ウェブからのアクセス）を受け取るには、ポート8080でリッスンするウェブサーバーを起動する必要があります。─ ポート8080を使って外部からのアクセスを受け付ける準備をしている状態のことです ─<br>
    entrypointには、そのためのコマンドを設定します。</p>
   <p>当サイトのようにPythonを使っている場合、entrypointを指定しないと、App Engineが自動的にGunicornというウェブサーバーを起動してくれます。─ 詳しく後述します ─<br>
    しかし特別な設定やカスタマイズをしたい場合は、自分でentrypointを指定することができます。<br>
    例えば独自のサーバーを起動するコマンドを指定する場合は、app.yamlファイルに以下のように記述します。</p>
  </div>

  <div class="code-container">
   <pre><code class="language-yaml">
entrypoint: python my_server.py

</code></pre>
  </div>

  <p>すでに上記で簡単に触れましたが、もしentrypointを明示的に指定しなかった場合でも、Google App
   Engineが内部的にGunicornというウェブサーバーを使用してアプリを起動し、ポート8080でのリクエストを受け付けるようにしてくれます。<br>
   Google App Engineがバックグラウンドで必要な設定を自動で行ってくれるので、ポート8080を手動で設定する必要がないわけです。</p>

  <div class="flowerclearfix">
   <div class="flowerfade-out">
    <img src="/flower1/forest1(296).jpg" alt="フェードアウト効果の草花写真">
   </div>
   <p>Gunicorn（Green Unicorn）は、Pythonで書かれたWSGI（Web Server Gateway Interface）サーバーです。<br>
    簡単に言えば、Pythonのウェブアプリケーションを効率的に動かすためのサーバーです。</p>

   <dl>
    <dt>パフォーマンス</dt>
    <dd>軽量で、高性能なHTTPサーバーとして知られています。</dd>
    <dt>互換性</dt>
    <dd>多くのPythonフレームワーク（例：Django、Flaskなど）と互換性があります。</dd>
    <dt>簡単な設定</dt>
    <dd>設定が比較的簡単で、シンプルなコマンドで起動できます。</dd>
    <dt>スケーラビリティ</dt>
    <dd>複数のプロセスを使用してリクエストを処理するため、高トラフィックにも対応できます。</dd>
   </dl>
  </div>

  <p>例えば、FlaskアプリケーションをGunicornで起動する場合は、以下のようにコマンドを実行します。</p>

  <div class="code-container">
   <pre><code class="language-bash">
gunicorn myapp:app

</code></pre>
  </div>

  <p>ここで、myappはPythonファイルの名前、appはFlaskアプリケーションのインスタンス名です。</p>

  <p>このように既存の動作や設定を上書きして変更することをオーバーライド（override）と言うこともあります。<br>
   App Engineが通常自動的に行う設定を変更して、自分で特別なサーバーの起動方法を指定したい場合に、そのコマンドをentrypointで設定することで、App
   Engineが通常使う方法を「オーバーライド」することができるということです。</p>

  <h5>env_variables</h5>
  <p><span class="small-orange-text">※必ずしも設定する必要はありません。</span></p>
  <p>Google App Engine (GAE) では app.yaml でアプリの設定を行います。<br>
   このファイルの中で、環境変数を定義できます。<br>
   環境変数はプログラムにとって重要な情報を外部から渡すための仕組みです。<br>
   例えばある設定値をプログラム内で直接書くのではなく、外部からその値を与えることで、プログラムの再利用性が向上したり、設定の変更が容易になります。</p>

  <p>App Engineにおける環境変数は、以下のルールに従って定義されます。</p>

  <ul>
   <li>キー（変数名）はアルファベットまたはアンダースコア (_) で始まり、その後に英数字またはアンダースコアが続く必要があります。<br>
    例:MY_VARIABLE, ANOTHER_VAR123</li>
   <li>ただし、GAE で始まる名前は予約されており、使用できません。</li>
  </ul>

  <p>具体的には、次のように app.yaml ファイルに環境変数を定義します。</p>

  <div class="code-container">
   <pre><code class="language-yaml">
env_variables:
DJANGO_SETTINGS_MODULE: "myapp.settings"

</code></pre>
  </div>

  <p>Python では、定義した環境変数を os.environ という辞書を通じてアクセスできます。<br>
   例えば、上記の環境変数を読み取るには次のようにします。</p>

  <div class="code-container">
   <pre><code class="language-python">
import os

# 環境変数の値を取得
settings_module = os.environ.get('DJANGO_SETTINGS_MODULE')
print(settings_module) # "myapp.settings" と表示されるはずです。

</code></pre>
  </div>

  <p>このように環境変数を使うことで、アプリの設定や変更が柔軟に行えるようになります。<br>
   つまり、上記のようにapp.yamlファイルに環境変数を定義してからDjangoアプリをPythonで構成、Pythonスクリプト内で os モジュールを使用して環境変数を取得します。<br>
   それからApp Engineにアプリをデプロイすると、指定した環境変数の値が読み取られ、"myapp.settings" と表示されるのです。</p>

  <h5>error_handlers</h5>
  <p><span class="small-orange-text">※必ずしも設定する必要はありません。</span></p>
  <p>エラーハンドラはアプリでエラーが発生したときに表示されるカスタムエラーページを設定するためのものです。<br>
   ユーザーがエラーに遭遇したときに見やすくわかりやすいページを提供できます。<br>
   設定できる要素として、次のようなものがあります。</p>

  <dl>
   <dt>error_code</dt>
   <dd>エラーの種類を指定するためのオプションの要素です。次のいずれかを指定できます。</dd>
   <dd>over_quota: アプリがリソースの割り当てを超えたときに表示されます。</dd>
   <dd>timeout: アプリからレスポンスが返される前に時間切れになったときに表示されます。</dd>

   <dt>file</dt>
   <dd>エラーが発生したときに表示される静的ファイル（HTMLファイルなど）のパスを指定します。指定されたファイルが表示され、ユーザーに対してエラーメッセージを提供します。</dd>
  </dl>

  <p>app.yamlには次のように記述します。</p>
  <div class="code-container">
   <pre><code class="language-yaml">
error_handlers:
- file: default_error.html
- error_code: over_quota
file: over_quota.html

</code></pre>
  </div>

  <p>上記app.yamlだと、次のように動作します。<br>
   default_error.html ファイルは、全てのエラーに対するデフォルトのエラーページとして表示されます。<br>
   over_quota エラーの場合は、over_quota.html ファイルが表示されます。</p>

  <p>注意点として、カスタムエラーページのファイルパスが他の静的ファイルハンドラのパスと重ならないようにすること。<br>
   また、カスタムエラーページのデータサイズは10KB未満にする必要があります。<br>
   このように設定することで、ユーザーに対してより分かりやすいエラーメッセージを表示することができます。</p>

  <h5>handlers</h5>
  <div class="flowerclearfix">
   <div class="flowerfade-out">
    <img src="/flower1/forest1(101).jpg" alt="フェードアウト効果の草花写真">
   </div>
   <p><span class="small-orange-text">※省略可能ではありますが、非常に重要な記述です。</span></p>
   <p>簡単に言うと、URLパターンと処理方法のリストです。<br>
    App Engineにおいて特定のURLにアクセスがあったときに、それをどのように処理するかを定義します。</p>

   <dl>
    <dt>動的コンテンツの処理</dt>
    <dd>ユーザーが特定のURLにアクセスしたとき、プログラムコードを実行して、そのリクエストに応じた内容を返します。<br>
     例えば、データベースからの情報を表示するなど。</dd>

    <dt>静的ファイルの提供</dt>
    <dd>画像や CSS、JavaScriptファイルなど、プログラムコードとは別にアップロードされた静的なファイルをユーザーに提供します。<br>
     これらのファイルは、通常、デザインやインタラクティブな要素を実現するために使われます。</dd>
   </dl>
  </div>

  <p>つまりhandlersは、どのURLにアクセスがあった場合にどのファイルやプログラムを使って応答するかを決める設定項目になります。<br>
   アプリケーションの動作や見た目を柔軟にコントロールするために必要な記述でしょう。</p>

  <h5>inbound_services</h5>
  <p><span class="small-orange-text">※必ずしも記述する必要はありません。</span></p>
  <p>Google App Engine上でアプリケーションが特定のリクエストを受け取れるようにするための設定です。<br>
   これらのサービスを有効にすることで、アプリケーションが適切に動作するようになります。<br>
   アプリケーションが受け取るインバウンドリクエストを指定します。─ 外部からのものという意味です。 ─</p>

  <p>warmup は特に「ウォームアップリクエスト」を有効にする設定です。<br>
   ウォームアップリクエストとは、App Engineが新しいインスタンス（アプリケーションのコピー）を起動する際に、そのインスタンスを事前に準備しておくためのリクエストです。<br>
   ユーザーがアクセスする前にインスタンスを温めておき、応答時間を短縮することができます。</p>

  <p>inbound_services セクションを使って warmup を有効にするためのコードを見てみましょう。</p>

  <div class="code-container">
   <pre><code class="language-yaml">
inbound_services:
- warmup

</code></pre>
  </div>

  <p>この設定を行うことで、新しいインスタンスが起動される際に自動的にウォームアップリクエストが送信され、アプリケーションがより迅速に応答できるようになります。</p>

  <h2>App Engineにおけるインスタンス</h2>
  <div class="flowerclearfix">
   <div class="flowerfade-out">
    <img src="/flower1/forest1(102).jpg" alt="フェードアウト効果の草花写真">
   </div>
   <p>App Engine でアプリケーションを実行するために「インスタンス」という単位が使われます。<br>
    インスタンスは、実際にアプリケーションコードを実行する環境のことです。<br>
    この言葉は非常に重要です。</p>

   <p>「inbound_servicesセクションを使ってwarmupを有効にする」説明文中にて、新しいインスタンス（アプリケーションのコピー）という表現を使っています。<br>
    この「コピー」という言葉が指しているのは、アプリケーションそのものではなく、アプリケーションの実行環境の複製です。<br>
    つまり、同じアプリケーションコードを実行する複数の環境（インスタンス）が存在するという意味です。</p>
  </div>


  <p>アプリケーションが人気で多くのユーザーがアクセスする場合、一つのインスタンスだけでは対応できません。<br>
   そのため、App Engine は必要に応じて新しいインスタンスを起動し、負荷を分散させます。<br>
   この仕組みがあることで、アクセスが増えてもアプリケーションが速く、安定して動作するようになります。</p>

  <p>Googleのものに限らず、クラウドに関連する用語は専門的に感じられることがあります。<br>
   ここで、デプロイとインスタンスについておさらいしてみましょう。</p>
  <dl>
   <dt>デプロイ</dt>
   <dd>ユーザーがアプリケーションを App Engine にアップロードすることを意味します。</dd>

   <dt>インスタンス</dt>
   <dd>デプロイされたアプリケーションを実行するための複数の環境です。<br>
    これが「コピー」と言われることもあります。</dd>
  </dl>

  <p>App Engineについて小話をしてみますね？<br>
   例えば、あなたが大人気のレストランを経営しているとしましょう。<br>
   一つのキッチン（インスタンス）だけでは全てのお客様に迅速に料理を提供するのが難しいため、複数のキッチン（インスタンス）を用意します。<br>
   それぞれのキッチンでは同じメニュー（アプリケーションコード）が作られますが、複数のキッチンがあることで多くのお客様に対応できるようになります。<br>
   こんな感じで、App Engine では負荷に応じて新しいインスタンス（キッチン）を起動し、アプリケーションがスムーズに動作するようにしているのです。</p>

  <h5>instance_class</h5>
  <p><span class="small-orange-text">※省略できますが、明示的に指定しておいたほうが良いでしょう。</span></p>
  <p>ここは「オンプレミスとクラウド」の違いがはっきりと分かる設定ですね。<br>
   オンプレミスは、データやシステムを自分の会社のサーバーに置くこと。<br>
   クラウドは、インターネットを通じて他の会社のサーバーにデータやシステムを置くこと。<br>
   自宅保管と貸し倉庫の違いに似ていますね。</p>

  <p>インスタンスクラスは、アプリケーションを動かすためのサーバーの性能や容量を決める設定です。<br>
   まるでコンピュータのスペックを選ぶようなものです。<br>
   サービスのスケーリングは、アプリケーションのアクセス量に応じてサーバーの数や性能を自動的に増減させる仕組みです。<br>
   では、これらの基礎を把握したうえで、App Engineでどのような設定ができるのか、見ていきます。</p>

  <h4>自動スケーリング</h4>
  <p>自動スケーリングはアクセスが増えたら自動でサーバーを増やし、減ったらサーバーを減らす仕組みです。<br>
   次のようなインスタンスクラスがあります。</p>
  <dl>
   <dt>F1</dt>
   <dd>基本的な性能。デフォルトの設定です。</dd>

   <dt>F2</dt>
   <dd>F1の2倍の性能。</dd>

   <dt>F4</dt>
   <dd>F1の4倍の性能。</dd>

   <dt>F4_1G</dt>
   <dd>F4と同じ性能ですが、メモリ容量が多い。</dd>
  </dl>

  <p>必要に応じて、automatic_scaling要素を使います。<br>
   インスタンスの数、レイテンシ（遅延）、同時接続の最小数と最大数などを調整することができます。</p>

  <p>把握しておいたほうが良い事柄として、インスタンスクラスをF2以上に設定している場合の設定があるでしょう。<br>
   max_concurrent_requests（同時接続数）をデフォルトの10より大きい値に設定するとインスタンスを最適化できます。<br>
   この最適な値を見つけるためには、少しずつ値を増やしてアプリケーションのパフォーマンスを監視する必要があります。</p>

  <h4>基本スケーリングと手動スケーリング</h4>
  <p>これらは一定の数のサーバーを使う方法です。</p>
  <dl>
   <dt>基本スケーリング</dt>
   <dd>一定の数のサーバーを使い、必要に応じて少し自動で調整します。</dd>

   <dt>手動スケーリング</dt>
   <dd>サーバーの数を固定して使います。</dd>
  </dl>

  <p>インスタンスクラスには次のような種類があります。</p>

  <dl>
   <dt>B1</dt>
   <dd>基本的な性能。</dd>

   <dt>B2</dt>
   <dd>B1の2倍の性能。デフォルト設定です。</dd>

   <dt>B4</dt>
   <dd>B1の4倍の性能。</dd>

   <dt>B4_1G</dt>
   <dd>B4と同じ性能ですが、メモリ容量が多い。</dd>

   <dt>B8</dt>
   <dd>B1の8倍の性能。</dd>
  </dl>

  <p>基本スケーリングや手動スケーリングを使う場合は、それぞれの要素（basic_scaling または manual_scaling）を指定する必要があります。</p>

  <p>App Engineに初めて設定する場合は、デフォルトのF1やB2を試してみて、必要に応じて変更するのが良いです。
   アクセスが変動する場合は自動スケーリング、一定の負荷がかかる場合は基本スケーリングや手動スケーリングを選びましょう。</p>

  <h4>F1とB1の違い</h4>
  <p>Fはフロントエンド、Bはバックエンドを意味します。</p>

  <p class="gra">F（フロントエンド）</p>
  <p>Fクラスのインスタンスは、短時間で素早くスケールアップやスケールダウンが必要なアプリケーション向けです。<br>
   例えばウェブサイトのフロントエンドや、ユーザーの操作に即座に応じる必要があるサービスに向いています。<br>
   基本的にアクセスが増減するタイミングが予測しにくい場合に適しています。</p>

  <p class="gra">B（バックエンド）</p>
  <p>Bクラスのインスタンスは、比較的長時間稼働し続けるアプリケーション向けです。<br>
   例えばデータベースのバックエンドや、一定の作業を継続的に行う必要があるサービスに向いています。<br>
   アクセスが安定している場合や、特定の時間に負荷が集中する場合に適しています。</p>

  <p>基礎的設定であるF1とB1について見てみましょう。</p>

  <dl>
   <dt>F1</dt>
   <dd>主に短時間のレスポンスを求められる用途向け</dd>
   <dd>自動スケーリングでアクセス量に応じて柔軟に対応</dd>

   <dt>B1</dt>
   <dd>一定時間以上の継続的な稼働を求められる用途向け</dd>
   <dd>手動スケーリングや基本スケーリングで安定した性能を提供</dd>
  </dl>

  <p>例えば、人気のイベントなどが開催されているときにアクセスが急増するウェブサイトの場合はF1が適しています。<br>
   一方、バックグラウンドでデータを処理し続けるアプリケーションの場合はB1が適しています。</p>

  <p>個人サイト領域であれば、静的なWebサイトという形でホスティングすることが多いでしょう。<br>
   特に初期のころはF1インスタンスクラスで十分なことが多いです。<br>
   自動スケーリングでF1を使用することで、アクセスが増えても柔軟に対応できます。<br>
   一方この設定を省略した場合、GoogleはデフォルトでF1を使用します。<br>
   つまり、特に指定しなくてもF1が使われるので、基本的には問題ないと言ってよいです。<br>
   必要があれば後でインスタンスクラスを変更することもできるので、まずはF1で試してみて、様子を見ながら調整するのが一般的です。</p>

  <h5>runtime</h5>
  <p><span class="small-orange-text">※これは必須の記述です</span></p>
  <p>ここいらへんで、おさらいの時間を作ります。<br>
   私がTwitterを見ている限り、コードを書いた上での個人サイトといえば「HTMLとレンタルサーバー」というキーワードが圧倒的大多数です。<br>
   例えばGCPなどクラウドを用いてホスティングしている人は、本当にごくわずかでした。─ 普段から開発系のSEアカウント等は除いて ─</p>

  <p>App Engine（アプリケーションエンジン）はGoogleが提供しているクラウドサービスの一つで、ウェブアプリケーションをホスティングするためのプラットフォームです。<br>
   app.yamlは、このApp Engineにデプロイするアプリケーションの設定ファイルです。<br>
   このファイルには、アプリケーションの動作環境や各種設定を記述します。</p>

  <p>まとめると次のようになります。</p>

  <dl>
   <dt>App Engine</dt>
   <dd>Googleのウェブアプリケーションホスティングサービス。</dd>

   <dt>app.yamlファイル</dt>
   <dd>アプリケーションの設定ファイル。</dd>

   <dt>ランタイム環境（runtime）</dt>
   <dd>アプリケーションを実行するためのプログラミング言語とそのバージョン。</dd>

   <dt>例（runtime: python312）</dt>
   <dd>Python 3.12の言語でアプリケーションを動かす設定。─ 他の言語でも良いです。後述します。 ─</dd>
  </dl>

  <p>「runtime」という項目は、「ランタイム環境」を指定するためのものです。<br>
   ランタイム環境とは、アプリケーションを実行するためのプログラミング言語やそのバージョンのことを指します。<br>
   たとえば、以下のように設定します。</p>

  <div class="code-container">
   <pre><code class="language-yaml">
runtime: python312

</code></pre>
  </div>

  <p>この例では、「python312」と指定しています。<br>
   これは、「Python 3.12」というバージョンのプログラミング言語を使用することを意味しています。<br>
   つまり、App Engine上でこのアプリケーションを実行する際に、Python 3.12が使われるということです。</p>

  <p>App Engineにはさまざまなランタイム環境があります。<br>
   よく聞く代表例は次のようなものがありますね。</p>

  <dl>
   <dt>Python</dt>
   <dd>python310、python311</dd>

   <dt>Java</dt>
   <dd>java8、java11</dd>

   <dt>Node.js</dt>
   <dd>nodejs16、nodejs18</dd>

   <dt>Go</dt>
   <dd>go116、go118</dd>

   <dt>PHP</dt>
   <dd>php74、php80</dd>

   <dt>Ruby</dt>
   <dd>ruby30、ruby31</dd>
  </dl>

  <p>これらのランタイム環境を使用して、対応するプログラミング言語とバージョンでアプリケーションを実行することができます。<br>
   設定ファイルに指定することで、App Engineが自動的に適切なランタイムを使用してアプリケーションをデプロイ・実行する仕組みです。</p>

  <h5>service</h5>
  <p><span class="small-orange-text">※サービスを作成する場合には必須です。default サービスでは省略できます。</span></p>
  <p>App Engineではウェブアプリケーションを「サービス」として管理します。<br>
   このサービスには名前を付ける必要があります。<br>
   サービスの設定は、アプリケーションの異なる部分を分けて管理するのに役立つでしょう。<br>
   とりあえず一つのサービスを「default」として設定できます。<br>
   この場合、特に名前を付ける必要はありません。<br>
   サービス名やバージョン名には次のようなルールがあります。</p>

  <dl>
   <dt>使える文字</dt>
   <dd>数字（0-9）、英字（a-z、A-Z）、ハイフン（-）</dd>

   <dt>長さの制限</dt>
   <dd>VERSION-dot-SERVICE-dot-PROJECT_ID という形式で、全体の長さが63文字以内にする必要があります。</dd>

   <dt>ハイフンの位置</dt>
   <dd>名前の先頭や末尾にハイフンは使えません。</dd>

   <dt>名前の一意性</dt>
   <dd>各サービスとバージョンには一意の名前を付ける必要があります。同じ名前を使ってはいけません。</dd>
  </dl>

  <p>app.yamlには次のように書きます。</p>
  <div class="code-container">
   <pre><code class="language-yaml">
service: service-name

</code></pre>
  </div>

  <p>この例では、サービス名として「service-name」を設定しています。<br>
   この名前が他のサービス名やバージョン名と重複しないようにする必要があります。</p>

  <h5>service_account</h5>
  <p><span class="small-orange-text">※必ずしも設定する必要はありません。</span></p>
  <p>特定のバージョンに関連付けられたサービスアカウントを指定するために使われます。<br>
   このサービスアカウントは、他のGoogle Cloudサービスにアクセスする際に使われます。<br>
   サービスアカウントを指定することで、アプリケーションが適切な権限でGoogle Cloudサービスにアクセスできるようになります。<br>
   この設定はオプションですが、セキュリティや権限管理の観点から非常に重要です。<br>
   例えば、データベースへのアクセスや、他のAPIを利用する際に必要な認証情報として機能します。<br>
   形式は次の通りです。</p>

  <span class="codecolor">[SERVICE_ACCOUNT_NAME]@[PROJECT_ID]<br>.iam.gserviceaccount.com</span>

  <ul>
   <li>SERVICE_ACCOUNT_NAME：サービスアカウントの名前</li>
   <li>PROJECT_ID：プロジェクトのID</li>
  </ul>

  <p>yamlには次のように指定します。</p>

  <div class="code-container">
   <pre><code class="language-yaml">
service_account: my-service-account@my-project-id.iam.gserviceaccount.com

</code></pre>
  </div>

  <p>この例では、「my-service-account」という名前のサービスアカウントを「my-project-id」というプロジェクトに関連付けています。</p>

  <h5>vpc_access_connector</h5>
  <span class="small-orange-text">※必ずしも設定する必要はありません。</span>
  <p>vpc_access_connector（PCアクセスコネクタ）は、アプリケーションが仮想プライベートクラウド（VPC）ネットワークの内部リソースにアクセスできるようにするための設定です。
   サーバーレス環境（例えばGoogle CloudのApp Engine）で、この設定を使ってネットワークリソースにリクエストを送信することができます。
   設定項目は次の通りです。</p>

  <p><strong>name</strong></p>
  <p>これは、サーバーレスVPCアクセスコネクタの完全修飾名です。<br>
   形式は <span class="codecolor">"projects/PROJECT_ID/locations/REGION/<br>
    connectors/CONNECTOR_NAME"</span> です。</p>

  <dl>
   <dt>PROJECT_ID</dt>
   <dd>プロジェクトのID</dd>

   <dt>REGION</dt>
   <dd>リージョン（地域）</dd>

   <dt>CONNECTOR_NAME</dt>
   <dd>コネクタの名前</dd>
  </dl>

  <p>yamlでは、次のように書きます。</p>

  <div class="code-container">
   <pre><code class="language-yaml">
vpc_access_connector:
  name: "projects/my-project/locations/us-central1/connectors/my-connector"

</code></pre>
  </div>

  <p><strong>egress_setting</strong></p>

  <p>これはオプションで省略可能なんですよね。<br>
   デフォルトは <span class="codecolor">private-ranges-only</span> です。<br>
   設定値は次の通りです。</p>

  <dl>
   <dt>private-ranges-only (デフォルト)</dt>
   <dd>内部IPアドレスへのリクエストはVPCネットワークに送信され、外部IPアドレスへのリクエストは公共のインターネットに送信されます。</dd>

   <dt>all-traffic</dt>
   <dd>すべてのリクエストがVPCネットワークに送信されます。</dd>
  </dl>

  <p>yamlには、次のように書きます。</p>
  <div class="code-container">
   <pre><code class="language-yaml">
vpc_access_connector:
  name: "projects/my-project/locations/us-central1/connectors/my-connector"
  egress_setting: all-traffic

</code></pre>
  </div>

  <p>要は vpc_access_connector の設定を使うことで、サーバーレスアプリケーションがVPCネットワークの内部リソースにアクセスできるようになるのです。<br>
   特に内部システムやデータベースにアクセスする場合に役立ちます。</p>

  <h2>個人サイト向けのapp.yaml設定</h2>

  <p>App Engineの「app.yaml」ファイルは、Google App Engineアプリケーションのデプロイや動作に関する重要な情報をまとめて管理するためのものです。<br>
   このファイルには、アプリケーションの動作に関するさまざまな設定が含まれています。</p>

  <p class="gra">参考サイト</p>
  <p><a href="https://yaml.org/">yaml.org</a></p>

  <h3>ランタイムの指定</h3>
  <div class="flowerclearfix">
   <div class="flowerfade-out">
    <img src="/flower1/forest1(26).jpg" alt="フェードアウト効果の草花写真">
   </div>
   <p>使用するプログラミング言語やランタイム環境を指定します。<br>
    app.yamlファイルでは、アプリケーションがどのプログラミング言語やランタイム環境を使うかを指定することができます。<br>
    これをもって、Google App Engineがアプリケーションを正しく実行するための環境を準備することになります。</p>
  </div>

  <p class="gra">プログラミング言語</p>
  <p>アプリケーションが書かれている言語です。<br>
   例えば、Python、Java、Node.jsなどです。</p>

  <p class="gra">ランタイム環境</p>
  <p>アプリケーションを実行するためのソフトウェア環境です。プログラミング言語に対応したランタイムが用意されています。<br>
   例えば、Pythonを使ってアプリケーションを作成している場合、runtime:として記述されることになるでしょう。<br>
   Python 3.9のランタイム環境を使用することを指定すると、Google App EngineはPython 3.9を使ってアプリケーションを実行します。<br>
   同じようにnodejs14などを使うこともできます。<br>
   このように、app.yamlファイルで使用するプログラミング言語やランタイム環境を指定することで、アプリケーションが正しく動作するように設定します。</p>

  <h3>ハンドラの設定</h3>
  <p>URLパスとそれに対応するリクエストハンドラを定義します。<br>
   前述のようにapp.yamlは、Google App Engineでアプリケーションの設定を行うためのファイルです。<br>
   このファイルの中で、「URLパス」と「リクエストハンドラ」を定義します。</p>

  <p class="gra">URLパス</p>
  <p>ユーザーがウェブブラウザに入力するアドレスの一部です。<br>
   例えば、/homeや/aboutなどです。</p>

  <p class="gra">リクエストハンドラ</p>
  <p>特定のURLパスにアクセスがあったときに、そのリクエストを処理するプログラムや関数のことです。<br>
   簡単に言うと、app.yamlファイルで「このURLにアクセスがあったら、このプログラムを実行してね」と指示を出している感じです。<br>
   例えば、次のような設定があったとします。</p>

  <div class="code-container">
   <pre><code class="language-yaml">
# yamlの記述内容
handlers:
- url: /home
 script: home.app
- url: /about
 script: about.app
  </code></pre>
  </div>

  <p>この場合、ユーザーが/homeにアクセスすると、home.appというプログラムが実行され、/aboutにアクセスすると、about.appというプログラムが実行されます。</p>

  <h4>インスタンスの設定</h4>
  <p>インスタンスのスケーリングやクラスを設定します。<br>
   app.yamlファイルでインスタンスのスケーリングやクラスを設定することで、アプリケーションのパフォーマンスを最適化し、コストを管理することができます。</p>

  <p class="gra">インスタンスのスケーリング</p>
  <p>アプリケーションの負荷に応じてインスタンスの数を増減させる仕組みです。<br>
   例えば、アクセスが多いときにはインスタンスを増やし、少ないときには減らすことで、効率的にリソースを使うことができます。</p>

  <p class="gra">インスタンスのクラス</p>
  <p>インスタンスの性能やコストに関する設定です。<br>
   例えば、高性能なインスタンスを使うか、低コストなインスタンスを使うかを選ぶことができます。</p>

  <p>例えば、次のようなことを指定していきます。</p>
  <ul>
   <li>[instance_class: F2]とすれば、F2クラスのインスタンスを使用することを指定しています。F2クラスは、比較的高性能なインスタンスですね。</li>
   <li>[automatic_scaling]とすれば、自動スケーリングの設定です。</li>
   <li>[min_instances: 1]とすれば、最低でも1つのインスタンスを常に稼働させることを指定しています。</li>
   <li>[max_instances: 5]とすれば、最大で5つのインスタンスまで増やすことができることを指定しています。</li>
  </ul>

  <h4>環境変数の設定</h4>
  <p>アプリケーションで使用する環境変数を定義します。<br>
   環境変数を使うことで、アプリケーションのコードを変更せずに設定情報を変更することができます。<br>
   セキュリティが向上し、設定の管理が簡単になります。</p>

  <p class="gra">環境変数</p>
  <p>アプリケーションが動作する際に必要な設定情報を外部から渡すためのものです。<br>
   例えば、データベースの接続情報やAPIキーなど、アプリケーションのコードに直接書きたくない情報を環境変数として設定します。</p>

  <p class="gra">app.yaml</p>
  <p>ファイルで環境変数を定義することで、これらの情報を簡単に管理できます。</p>

  <p>例えば、DATABASE_URL:
   "mysql://user:password@localhost/dbname"としてデータベースの接続情報を指定します。この情報を使って、アプリケーションはデータベースに接続します。<br>
   APIについてはAPI_KEY: "your-api-key-here"と書くことで、外部のサービスを利用するためのAPIキーを指定します。このキーを使って、アプリケーションは外部サービスにアクセスします。</p>

  <h4>静的ファイルとディレクトリを設定する方法</h4>
  <p class="gra">静的ファイルの設定</p>
  静的ファイルを提供するためには、app.yamlファイルにstatic_filesまたはstatic_dirを使用してハンドラを定義します。

  <h5>static_filesの使用例</h5>
  static_filesを使用すると、特定のファイルパターンに一致するファイルを提供できます。

  <div class="code-container">
   <pre><code class="language-yaml">
# yamlの記述内容
- url: /static(.*)
 static_files: static/\1
 upload: static/(.*)
  </code></pre>
  </div>

  <p><strong>(.*)</strong><br>
   これは正規表現のパターンで、任意の文字列（0文字以上）にマッチします。<br>
   括弧で囲まれているため、キャプチャグループとして機能します。<br>
   つまり、マッチした部分を後で参照できるように保存します。</p>

  <p><strong>\1</strong><br>
   これはキャプチャグループの参照です。<br>
   正規表現のパターンで最初にキャプチャされたグループ（この場合は(.*)）を指します。<br>
   \1は最初のキャプチャグループ、\2は2番目のキャプチャグループ、というように続きます。</p>


  <p class="gra">url: /static/(.*):</p>
  <p>/static/に続く任意の文字列にマッチします。<br>
   例えば、/static/image.pngや/static/css/style.cssなどです。</p>

  <p class="gra">static_files: static/\1:</p>
  <p>マッチしたURLのパスの部分（(.*)）をstatic/ディレクトリ内の対応するファイルにマッピングします。<br>
   例えば、/static/image.pngがリクエストされた場合、static/image.pngファイルが提供されます。</p>

  <p class="gra">upload: static/(.*):</p>
  <p>App Engineにアップロードされるファイルのパスを指定します。<br>
   static/ディレクトリ内の任意のファイルがアップロード対象となります。<br>
   この設定があることで、/static/に続く任意のパスがstaticディレクトリ内の対応するファイルにマッピングされ、App Engineにアップロードされるファイルも同様に指定されます。</p>

  <h5>static_dirの使用例</h5>
  <p>static_dirを使用すると、ディレクトリ全体を静的ファイルとして提供できます。</p>

  <div class="code-container">
   <pre><code class="language-yaml">
# yamlの記述内容
- url: /static
 static_dir: static
  </code></pre>
  </div>

  <p>この例では、/static URLに一致するリクエストがstaticディレクトリ内のファイルにマッピングされます。</p>

  <h2>app.yamlの構文例</h2>
  <p><span class="small-orange-text">下記コードのコピペはお勧めできません。</span></p>
  <p>Webアプリケーションのレベルやアクセス数によっては費用がかかる可能性がありますよ。<br>
   あくまでも私の環境に沿った上でのコードですし、頻繁に変更しています。<br>
   ちゃんと意味を理解してから書いた方が良いです。
  </p>
  <p class="codegra" id="app_yaml">Google App Engine の app.yaml</p>
  <div class="code-container">
   <pre><code class="language-yaml">
runtime: python312
instance_class: F1
env: standard

runtime_config:
  document_root: www

automatic_scaling:
  min_idle_instances: 0
  max_idle_instances: 3
  max_concurrent_requests: 200

handlers:
- url: /
  static_files: www/index.html
  upload: www/index.html

- url: /favicon.ico
  static_files: www/favicon.ico
  upload: www/favicon.ico

- url: /(.*)
  static_files: www/\1
  upload: www/(.*)

</code></pre>
  </div>

  <h4>YAML 設定ファイルの説明</h4>
  <div class="flowerclearfix">
   <div class="flowerfade-out">
    <img src="/flower1/forest1(301).jpg" alt="フェードアウト効果の草花写真">
   </div>
   <p><span class="codecolor">1. runtime: python312</span><br>
    使用するランタイム環境を指定します。<br>
    私の場合、Python 3.12 を使用しています。</p>

   <p><span class="codecolor">2. instance_class: F1</span><br>
    使用するインスタンスのクラスを指定します。<br>
    <span class="codecolor">F1</span> クラスのインスタンスを使用しています。<br>
    これは無料の低トラフィック用インスタンスクラスです。
   </p>

   <p><span class="codecolor">3. env: standard</span><br>
    環境を標準環境として指定します。</p>

   <p><span class="codecolor">4. runtime_config:</span><br>
    ランタイムの設定情報を定義するセクションです。</p>
   <p><span class="codecolor">document_root: www</span><br>
    ドキュメントルートを指定しています。<br>
    私の場合、アプリケーションのルートディレクトリが <span class="codecolor">www</span> フォルダです。</p>

   <p><span class="codecolor">5. automatic_scaling:</span><br>
    自動スケーリングの設定を指定するセクションです。</p>
   <ul>
    <li><span class="codecolor">min_idle_instances: 0</span><br>
     最小アイドルインスタンス数を 0 に設定します。<br>
     インスタンスがアイドル状態になったとき、それを保持する最小の数です。</li>
    <li><span class="codecolor">max_idle_instances: 3</span><br>
     最大アイドルインスタンス数を 3 に設定します。<br>
     インスタンスがアイドル状態になったとき、それを保持する最大の数です。</li>
    <li><span class="codecolor">max_concurrent_requests: 200</span><br>
     1 つのインスタンスで同時に処理できるリクエストの最大数を 200 に設定します。</li>
   </ul>
  </div>

  <p><span class="codecolor">6. handlers:</span><br>
   URL ハンドラーのリストを定義するセクションです。<br>
   各ハンドラーが特定の URL パターンに対してどのような操作を行うかを指定します。</p>
  <ul>
   <li><span class="codecolor">url: /</span><br>
    <span class="codecolor">/</span> に一致する URL に対するハンドラーを指定します。
   </li>
   <ul>
    <li><span class="codecolor">static_files: www/index.html</span><br>
     静的ファイル <span class="codecolor">www/index.html</span> を提供します。</li>
    <li><span class="codecolor">upload: www/index.html</span><br>
     GAE にデプロイするときに <span class="codecolor">www/index.html</span> をアップロードします。</li>
   </ul>
   <li><span class="codecolor">url: /favicon.ico</span><br>
    <span class="codecolor">/favicon.ico</span> に一致する URL に対するハンドラーを指定します。
   </li>
   <ul>
    <li><span class="codecolor">static_files: www/favicon.ico</span><br>
     静的ファイル <span class="codecolor">www/favicon.ico</span> を提供します。
    </li>
    <li><span class="codecolor">upload: www/favicon.ico</span><br>
     GAE にデプロイするときに <span class="codecolor">www/favicon.ico</span> をアップロードします。
    </li>
   </ul>
   <li><span class="codecolor">url: /(.*)</span><br>
    任意の URL に一致するハンドラーを指定します。<br>
    正規表現 <span class="codecolor">(.*)</span> を使用して、どの URL にもマッチさせます。</li>
   <ul>
    <li><span class="codecolor">static_files: www/\1</span><br>
     URL に対応するファイルを <span class="codecolor">www</span> フォルダから提供します。</li>
    <li><span class="codecolor">upload: www/(.*)</span><br>
     GAE にデプロイするときに <span class="codecolor">www</span> フォルダ内の任意のファイルをアップロードします。</li>
   </ul>
  </ul>

  <p class="feintag">ここから先は、また後日加筆します</p><br>

  <h2>個人サイトをクラウドサービスで公開する</h2>
  <div class="flowerclearfix">
   <div class="flowerfade-out">
    <img src="../flower1/flower1(34).JPG" alt="フェードアウト効果の草花写真">
   </div>
   <p>Azureならほとんど専用サービスとも言える「<a href="https://azure.microsoft.com/ja-jp/products/app-service/static">Azure Static
     Web Apps</a>」というプロダクトがあるんですよね。<br>
    HTML、CSS、JavaScriptなどの静的コンテンツを簡単にデプロイし、グローバルに配信するためのサービスとなります。</p>
   <p>GCPだと「<a href="https://firebase.google.com/docs/hosting?hl=ja">Firebase Hosting</a>」もあって、これでも良いと思います。<br>
    私がひとまずGoogle App Engineを選んだのは、App Engineのほうが歴史が長く、専門書の出版数も多いからです。<br>
    FirebaseはGoogleに買収され、その後でFirebase Hostingが導入されたんだよね。</p>
   <p>AWSにも「<a href="https://aws.amazon.com/jp/amplify/">AWS Amplify</a>」というのがありますよ。<br>
    静的ウェブサイトやシングルページアプリケーション（SPA）のホスティングを提供し、グローバルCDN、カスタムドメイン、継続的デプロイなどの機能を備えています。</p>
  </div>

  <p>情報商材屋ではないのでね。今は骨組みだけですが、徐々に内容を具体化していきます。<br>
   個人サイトについてX（旧Twitter）でよく話題になるhtml・css・JavaScriptというのは、要するにフロントエンドに関するコードなんですよね。<br>
   バックエンドは、例えば私がローカルサーバーを立てるのにインストールしたPythonなんかがそうです。<br>
   それで、ここでお話ししているクラウドというのは…一言で書くのは極めて難しいですが、インフラと言えば良いでしょうか。<br>
   個人サイト作るだけなのにサーバー実機なんか買わないでしょ？</p>

  <h2>ホスティング先のクラウド選び</h2>
  まずは料金が安いGoogle Cloudから探してみるのがいいんじゃないかな。<br>
  私は次のようにして、ひとまずApp Engineを試しています。
  <ol>
   <li><a href="https://cloud.google.com/?hl=ja">Google Cloud</a>からプロダクトを選択。より詳しくやりたいことが具体的になっている場合は<a
     href="https://cloud.google.com/products?hl=ja#featured-products/">Google Cloud プロダクト</a></li>
   <li>大項目を選択する。─ ここではサーバーレスを選択します。なぜサーバーレスなのかですが、<a
     href="https://cloud.google.com/docs/application-hosting?hl=ja">アプリケーション
     ホスティングの概要</a>に詳しく書いてあります。いきなりIaaSを検討しなくて良いでしょう。 ─</li>
   <li>Cloud Run・Cloud Functions・App Engine・Workflows・API Gatewayをさっと見てから…</li>
   <li><a href="https://cloud.google.com/docs/get-started/aws-azure-gcp-service-comparison?hl=ja">AWS サービスや Azure
     サービスと Google Cloud を比較する</a>で似たようなサービスをそれぞれ調べる。</li>
   <li>それらのプロダクトの中から、自分のニーズにあったものを選ぶ。</li>
  </ol>


  <h2>レンタルサーバー VS クラウドサービス</h2>
  <p>やってることは似たようなもんだと思うんですけどね。<br>
   AWS、GCP、Azureなどのクラウドサービスの台頭は、レンタルサーバー業界に大きな影響を与えています。<br>
   これらのクラウドサービスは、スケーラビリティ、柔軟性、コスト効率の面で優れており、多くの企業や個人が従来のレンタルサーバーから移行する要因となっているんですよね。</p>

  <h5>コストで比べる</h5>
  <p>クラウドサービスは従量課金制や無料の初期利用枠を提供しており、初期コストを抑えたいユーザーにとって魅力的です。<br>
   私なんか思いっきりこのタイプですよ。<br>
   クラウドにホスティングすれば、無料で広告無しの自由自在なWebサイトにできるのです。</p>

  <h5>技術で比べる</h5>
  <p>クラウドサービスは最新の技術を迅速に取り入れることができ、セキュリティやパフォーマンスの面でも優れています。<br>
   さすがにAWS、GCP、Azureのクラウドですからね。</p>

  <h5>運用の簡便さで比較する</h5>
  <p>クラウドサービスは、インフラの管理を自動化するツールやサービスを提供しており、ユーザーはより簡単に運用できます。<br>
   開発環境を整えるために個人でハイスペックPCを用意する必要がないのですよ。<br>
   私はずっとロースペックパソコンでWeb書いてます。</p>

  <h5>市場の変化</h5>
  <p>個人サイトを作る人が減少し、SNSやブログサービスの利用が増えていることも影響していますね。<br>
   私が「<a href="freesite.html">無料＆格安でWebサイトを作る</a>」にてお勧めしている Google Sites はホームページ作成サービス、Blogger はブログサービスです。<br>
   それで、イーロンマスクによってXの将来が不透明になってきたから、昔のように個人サイトが注目されるようになってきたという流れです。</p>

  <p>おそらく、これからも昔ながらの「レンタルサーバー」は、１つまた１つとサービス終了していくのではないかと。<br>
   その頃にはAWS、GCP、AzureなどのクラウドサービスがもっとIT初心者にも使いやすくなっていることでしょう。</p>


  <h3>個人サイトなら Cloud run と App Engine どちらが有利か？</h3>
  <div class="flowerclearfix">
   <div class="flowerfade-out">
    <img src="../flower1/flower1(128).JPG" alt="フェードアウト効果の草花写真">
   </div>
   <p>Google Cloudの「Cloud Run」と「App Engine」はどちらもサーバーレスのコンピューティングサービスです。<br>
    Cloud Runはコンテナベースで任意の言語やライブラリを使用できます。<br>
    リクエストに応じて自動的にスケールし、アイドル状態ではゼロまでスケーリングダウンします。<br>
    そのため、使用したリソースに基づいて課金され、アイドル状態のコストは低く抑えられます。</p>
  </div>

  <p>一方、App EngineはPaaS（Platform as a Service）です。<br>
   アプリケーションコードをデプロイするだけでインフラの管理をGoogleに任せることができます。<br>
   スタンダード環境とフレキシブル環境があります。<br>
   スタンダード環境は自動スケーリング、フレキシブル環境はカスタマイズ可能なインフラを提供します。<br>
   ソースコードを直接デプロイでき、特定のランタイム環境を選択するだけで動作します。<br>
   しかし、インスタンスベースの課金モデルでアイドル状態でも一定のコストが発生します。</p>

  <p>静的ウェブサイトのホスティングに関しては、Cloud Runはコンテナを使用します。<br>
   静的ファイルを含むコンテナイメージを作成し、それをデプロイすることでホスティングが可能です。<br>
   スケーリングの柔軟性とコスト効率の面で優れているんですよね。<br>
   一方、App Engineは特にスタンダード環境での静的ファイルのホスティングが簡単で設定も少なく済みます。<br>
   しかし、アイドル状態のコストが発生する点に注意が必要です。</p>

  <p>とはいえ、標準環境であれば無料枠があるわけです。<br>
   総合的に見ると、静的ウェブサイトのホスティングにはCloud Runがより適しているように思えますが、どちらのサービスも優れた機能を持っているため、具体的なニーズに応じて選択することが重要です。</p>


  <h4>クラウドサービスには無料枠がある</h4>
  <p>ここで、無料枠の話をしましょう。<br>
   静的ウェブサイトのホスティングに関して、Google Cloud RunとGoogle App Engineの無料枠を比較すると、以下の点を考慮する必要があります。</p>

  <p><strong>Google Cloud Run</strong></p>
  <ul>
   <li>CPU時間: 毎月最初の180,000 vCPU秒</li>
   <li>メモリ使用量: 毎月最初の360,000 GiB秒</li>
   <li>リクエスト数: 毎月最初の200万リクエスト</li>
   <li>ネットワーク: 北米内の下り（外向き）トラフィックは1GBまで無料</li>
  </ul>

  <p><strong>Google App Engine</strong></p>
  <ul>
   <li>インスタンス時間: Standard環境で1日あたり28インスタンス時間</li>
   <li>ネットワーク: 下り（外向き）トラフィックが1GB/日</li>
   <li>Cloud Storage: 5GBの無料ストレージ</li>
  </ul>

  <p><strong>比較ポイント</strong></p>
  <ul>
   <li>トラフィック: App Engineは1日あたり1GBの下りトラフィックが無料で、Cloud Runは月あたり1GBです。頻繁にアクセスされるサイトならApp Engineが有利です。</li>
   <li>インスタンス時間: App Engineは1日あたり28インスタンス時間が無料で、Cloud RunはCPU時間で計算されます。短時間で多くのリクエストがある場合はCloud Runが有利です。</li>
   <li>ストレージ: App Engineには5GBの無料ストレージが含まれていますが、Cloud Runにはストレージが含まれていません。</li>
  </ul>

  <p>静的ウェブサイトのホスティングに関しては、アクセス頻度や必要なリソースに応じて選ぶと良いでしょう。</p>
  <p>頻繁にアクセスされるサイトならApp Engine<br>
   短時間で多くのリクエストがある場合はCloud Run<br>
   これは目安に過ぎませんが、私の場合、旬な話題や時事ネタなど、浮き沈みが激しいものは避けています。
   よって、App Engineが有利であろうと判断してるんだよね。</p>


  <h3>Google Kubernetes Engine と Cloud Run の違い</h3>
  <p>「Cloud Run」と「Google Kubernetes Engine (GKE)」は、どちらもGoogle Cloudが提供するコンテナ運用サービスですが、用途や特徴が異なります。<br>
   Cloud Runはサーバーレスプラットフォームで、ステートレスなコンテナアプリケーションをサーバーレス環境で実行するためのもので、インフラ管理の手間を大幅に削減できます。<br>
   自動スケーリング機能によりリクエスト数に応じてスケールし、リクエストがない場合はゼロにスケールします。<br>
   デプロイも簡単で、単一のコマンドで可能です。</p>

  <p>一方、GKEはKubernetesをベースにしたコンテナオーケストレーションプラットフォームで、ステートフルおよびステートレスなアプリケーションの両方をサポートします。<br>
   クラスタの構成や管理を細かくカスタマイズでき、ネットワーキング、ストレージ、オブザーバビリティなどの設定が可能です。<br>
   GKEはCPU使用率やカスタムメトリクスに基づいて水平Pod自動スケーリングを行い、データベースやセッション管理が必要なステートフルなアプリケーションにも対応しています。</p>

  <p>Cloud Runはステートレスなアプリケーションを迅速にデプロイしたい場合やインフラ管理の手間を最小限に抑えたい場合、トラフィックの予測が難しい場合に向いてるかな。個人サイトに向いてるのはこっちだと思う。<br>
   GKEはステートフルなアプリケーションをデプロイしたい場合やKubernetesの高度な機能をフル活用したい場合、細かいカスタマイズが必要な場合に適しています。</p>

  <h3>GCP・AWS・Azureで独自ドメインを使う</h3>
  <p>GCP、AWS、Azureのいずれかを使用して独自ドメインを購入し適用する方法をサーっと書きますか。<br>
   そんなに難しくありませんが、大したものではないとはいえ費用がかかるからね。<br>
   ナシで済ませられるなら、それで良いと思いますけど。<br>
   独自ドメインなしでもGoogle検索に乗せることは可能ですよ？</p>

  <p class="gra">Google Cloud Platform (GCP)のケース</p>
  <ul>
   <li><strong>ドメインの購入</strong>
    <ul>
     <li>Google DomainsまたはCloud Domainsを使用してドメインを購入します。</li>
     <li>GCPコンソールで「Cloud Domains」を検索し、APIを有効にします。</li>
     <li>取得したいドメインを検索し、カートに追加して購入手続きを行います。</li>
    </ul>
   </li>
   <li><strong>DNS設定</strong>
    <ul>
     <li>Cloud DNSを使用してDNSゾーンを作成し、ドメインを設定します。</li>
     <li>GCPコンソールの「ネットワークサービス」から「Cloud DNS」を選択し、新しいゾーンを作成します。</li>
     <li>Aレコードを追加し、ウェブサイトのIPアドレスを設定します。</li>
    </ul>
   </li>
  </ul>

  <p class="gra">Amazon Web Services (AWS)のケース</p>
  <ul>
   <li><strong>ドメインの購入</strong>
    <ul>
     <li>Route 53を使用してドメインを購入します。</li>
     <li>AWSマネジメントコンソールにログインし、Route 53のダッシュボードに移動します。</li>
     <li>「ドメインの登録」をクリックし、取得したいドメインを検索してカートに追加します。</li>
     <li>必要な個人情報を入力し、購入手続きを完了します。</li>
    </ul>
   </li>
   <li><strong>DNS設定</strong>
    <ul>
     <li>Route 53でホストゾーンを作成し、DNSレコードを設定します。</li>
     <li>ホストゾーン内でAレコードを作成し、ウェブサイトのIPアドレスを設定します。</li>
    </ul>
   </li>
  </ul>

  <p class="gra">Microsoft Azureのケース</p>
  <ul>
   <li><strong>ドメインの購入</strong>
    <ul>
     <li>App Service ドメインを使用してドメインを購入します。</li>
     <li>Azureポータルでアプリの管理ページに移動し、左側のメニューから「カスタム ドメイン」を選択します。</li>
     <li>「App Service ドメインの購入」を選択し、取得したいドメインを入力して購入手続きを行います。</li>
    </ul>
   </li>
   <li><strong>DNS設定</strong>
    <ul>
     <li>Azure DNSを使用してDNSゾーンを作成し、ドメインを設定します。</li>
     <li>Azureポータルの「DNSゾーン」から新しいゾーンを作成し、Aレコードを追加してウェブサイトのIPアドレスを設定します。</li>
    </ul>
   </li>
  </ul>



  <h4>Webサイト制作に関係するミドルウェア</h4>

  <p>ミドルウェアというのは、オペレーティングシステム アプリケーションソフトウェアの間に位置するソフトウェアのことです。<br>
   OSが提供する基本機能とアプリケーションが必要とする特定の機能の橋渡しをする役割を持っています。<br>
   Webサイト制作に関連するミドルウェアには、以下のようなものがありますね。</p>

  <p>Webサーバ</p>
  <ul>
   <li><strong>Apache HTTP Server</strong>: 最も広く使用されているWebサーバの一つで、オープンソース</li>
   <li><strong>Nginx</strong>: 高速で軽量なWebサーバで、リバースプロキシやロードバランサとしても利用される</li>
   <li><strong>Microsoft IIS (Internet Information Services)</strong>: Windows Server上で動作するWebサーバ</li>
  </ul>

  <p>データベースサーバ</p>
  <ul>
   <li><strong>MySQL</strong>: オープンソースのリレーショナルデータベース管理システムで、多くのWebアプリケーションで使用される</li>
   <li><strong>PostgreSQL</strong>: 高度な機能を持つオープンソースのリレーショナルデータベース管理システム</li>
   <li><strong>MariaDB</strong>: MySQLのフォークで、オープンソースのリレーショナルデータベース管理システム</li>
  </ul>

  <p>アプリケーションサーバ</p>
  <ul>
   <li><strong>Apache Tomcat</strong>: JavaサーブレットやJSPを実行するためのオープンソースのアプリケーションサーバ</li>
   <li><strong>GlassFish</strong>: Java EEアプリケーションを実行するためのオープンソースのアプリケーションサーバ</li>
   <li><strong>Unicorn</strong>: Ruby on Railsアプリケーションを実行するためのアプリケーションサーバ</li>
  </ul>

  <p>クラウドサービスの中でミドルウェアの管理を気にせずに利用できるものとして、GCP、AWS、Azureには以下のようなサービスがあります。</p>

  <p class="gra">Google Cloud Platform (GCP)</p>
  <ul>
   <li><strong>App Engine</strong>: フルマネージドのプラットフォームで、アプリケーションのデプロイとスケーリングを簡単にできる</li>
   <li><strong>Cloud Functions</strong>: イベント駆動型のサーバーレスコンピューティングサービスで、コードを実行するためのインフラ管理が不要</li>
   <li><strong>Cloud Run</strong>: コンテナ化されたアプリケーションをサーバーレスで実行</li>
  </ul>

  <p class="gra">Amazon Web Services (AWS)</p>
  <ul>
   <li><strong>AWS Lambda</strong>: サーバーレスコンピューティングサービスで、コードを実行するためのサーバー管理が不要</li>
   <li><strong>AWS Fargate</strong>: コンテナをサーバーレスで実行できるサービスで、インフラ管理が不要</li>
   <li><strong>AWS Elastic Beanstalk</strong>: アプリケーションのデプロイとスケーリングを簡単に行えるフルマネージドサービス</li>
   <li><strong>Amazon S3</strong>: オブジェクトストレージサービスで、データの保存と取得が簡単にできる</li>
   <li><strong>Amazon EC2</strong>: 仮想サーバーを提供するサービスで、スケーラブルなコンピューティング能力を提供</li>
   <li><strong>Amazon RDS</strong>: フルマネージドのリレーショナルデータベースサービス</li>
  </ul>

  <p class="gra">Microsoft Azure</p>
  <ul>
   <li><strong>Azure Functions</strong>: イベント駆動型のサーバーレスコンピューティングサービスで、コードを実行するためのインフラ管理が不要</li>
   <li><strong>Azure App Service</strong>: ウェブアプリケーションのデプロイとスケーリングを簡単に行えるフルマネージドサービス</li>
   <li><strong>Azure Kubernetes Service (AKS)</strong>: コンテナ化されたアプリケーションを簡単にデプロイ、管理、スケーリングができる</li>
   <li><strong>Azure Virtual Machines</strong>: 仮想マシンを提供するサービスで、スケーラブルなコンピューティング能力を提供</li>
   <li><strong>Azure Blob Storage</strong>: オブジェクトストレージサービスで、データの保存と取得が簡単にできる</li>
   <li><strong>Azure SQL Database</strong>: フルマネージドのリレーショナルデータベースサービス</li>
  </ul>

  <p>これらのサービスは、ミドルウェアの管理を気にせずに利用できるため、開発者の負担を軽減します。</p>


  <h3>Webサイト制作とスケーリング・負荷分散</h3>

  <p>Webサイト制作では、スケーリングと負荷分散が重要です。<br>
   小規模な静的ウェブサイトレベルであれば、ここまで把握しなくて良いと思いますけどね。<br>
   「ふーん…」くらいの気持ちで眺めてもらえれば。<br>
   GCPはGoogle Cloud Load BalancingとAutoscaling。<br>
   AWSはElastic Load Balancing (ELB)とAuto Scaling。<br>
   AzureはAzure Load BalancerとAzure Virtual Machine Scale Sets。<br>
   このようなプロダクトを使うことで、トラフィックの負荷分散と自動スケーリングを実現します。</p>

  <p class="gra">GCPのケース</p>

  <p><strong>Google Cloud Load Balancing</strong><br>
   GCPのロードバランシングは、複数の仮想マシン（VM）インスタンスに対してトラフィックを分散します。</p>
  <ul>
   <li>スケーリング：アプリのトラフィック増加に対応。</li>
   <li>ヘルスチェック：不健康なVMを自動検出・削除、健康回復時に再追加。</li>
   <li>地理的トラフィックルーティング：最も近いVMにトラフィックをルーティング。</li>
  </ul>

  <p><strong>Autoscaling</strong><br>
   GCPのAutoscalingは、管理されたインスタンスグループ（MIG）内のVMインスタンスを自動的に追加または削除します。次の条件に基づいてスケーリングが行われます。</p>
  <ul>
   <li>CPU使用率：CPUの使用率に基づいてスケーリング。</li>
   <li>Cloud Monitoringメトリクス：特定のメトリクスに基づいてスケーリング。</li>
   <li>スケジュール：事前に設定されたスケジュールに基づいてスケーリング。</li>
   <li>ロードバランシングのサービングキャパシティ：インスタンスグループのサービングキャパシティに基づいてスケーリング。</li>
  </ul>

  <p>これらの機能を組み合わせることで、GCP上でのアプリケーションはトラフィックの増減に柔軟に対応し、コスト効率を高めることができます。</p>

  <p class="gra">AWSのケース</p>

  <p><strong>Elastic Load Balancing (ELB)</strong><br>
   ELBは、複数のEC2インスタンスに対してトラフィックを自動的に分散する機能を持っています。<br>
   これにより、特定のインスタンスに負荷が集中することを防ぎ、アプリケーションのパフォーマンスを維持します。<br>
   また、ELBは各インスタンスに対して定期的にヘルスチェックを行い、異常が検知されたインスタンスにはトラフィックを送信しないようにします。</p>

  <p><strong>Auto Scaling</strong><br>
   Auto Scalingは、トラフィックの変動に応じてEC2インスタンスの数を自動的に増減させる機能です。<br>
   あらかじめ設定したルールに基づいて、必要なリソースを確保し、運用の手間を大幅に削減します。</p>

  <p><strong>連携の仕組み</strong></p>
  <ul>
   <li>ELBのアタッチ: Auto ScalingグループにELBをアタッチすると、グループ内のインスタンスが自動的にELBに登録される。</li>
   <li>スケーリングポリシーの設定: ELBのメトリクス（例: ターゲットあたりのリクエスト数）を使って、Auto
    Scalingのスケーリングポリシーを設定できる。これで、トラフィックの増減に応じてインスタンス数を自動調整できる。</li>
   <li>ヘルスチェックの追加: Auto ScalingグループにELBのヘルスチェックを追加すると、異常なインスタンスを自動で置き換えられる。</li>
  </ul>

  <p><strong>ELBの種類</strong></p>
  <ul>
   <li>Application Load Balancer (ALB): HTTPやHTTPSのトラフィックをアプリケーション層でルーティングする。</li>
   <li>Network Load Balancer (NLB): TCPやUDPのトラフィックをトランスポート層でルーティングする。</li>
   <li>Gateway Load Balancer (GWLB): セキュリティアプライアンスにトラフィックを分散する。</li>
   <li>Classic Load Balancer (CLB): 従来型のロードバランサーで、現在はALBやNLBの利用が推奨される。</li>
  </ul>

  <p>ELBとAuto Scalingを連携させることで、トラフィックの変動に合わせて適切なリソースを自動的に確保し、トラフィックを最適に分散させることができます。<br>
   Webアプリケーションのパフォーマンスと可用性を高く維持できますね。</p>

  <p class="gra">Azureのケース</p>

  <p><strong>Azure Load Balancer</strong><br>
   Azure Load Balancerは、複数の仮想マシン（VM）に対してトラフィックを分散するサービスです。<br>
   特定のVMに負荷が集中することを防ぎ、アプリケーションのパフォーマンスを維持します。</p>
  <ul>
   <li>高可用性：トラフィックを複数のリージョンやアベイラビリティゾーンに分散できる。</li>
   <li>ヘルスプローブ：各VMの状態を定期的にチェックし、異常が検知されたVMにはトラフィックを送信しない。</li>
  </ul>

  <p><strong>Azure Virtual Machine Scale Sets</strong><br>
   Azure Virtual Machine Scale Setsは、トラフィックの増減に応じてVMの数を自動的に調整するサービスです。<br>
   必要なリソースを自動的に確保し、コスト効率を高めることができます。</p>
  <ul>
   <li>自動スケーリング：CPU使用率やメモリ使用率に基づいて、VMの数を自動で増減する。</li>
   <li>スケジュールベースのスケーリング：特定の時間帯に合わせてスケーリングを設定できる。</li>
  </ul>

  <p><strong>連携方法</strong></p>
  <ul>
   <li>Application Load Balancer (ALB): HTTPやHTTPSのトラフィックをアプリケーション層でルーティング。</li>
   <li>Network Load Balancer (NLB): TCPやUDPのトラフィックをトランスポート層でルーティング。</li>
   <li>Gateway Load Balancer (GWLB): セキュリティアプライアンスにトラフィックを分散。</li>
   <li>Classic Load Balancer (CLB): 従来型のロードバランサーで、現在はALBやNLBの利用が推奨。</li>
  </ul>

  <p>このように、AzureでもAWSと同様に、負荷分散と自動スケーリングを組み合わせて効率的なリソース管理が可能です。</p>

  <h4>Webサイト制作とネットワーク</h4>
  <p>ネットワークなんて本格的にやるとめちゃくちゃ難しいですけどね。<br>
   でもこのくらいなら…といいますか、個人でWebサイト作って遊ぶときに知っておくと便利な知識くらいは、書いていこうかと思います。</p>

  <p>※この項はクラウドのネットワークページへ移植すること</p>

  <p>ネットワークアドレスは、特定のネットワークを識別するためのアドレスです。<br>
   例えば、IPアドレス <code>192.168.1.0</code> は、<code>192.168.1.0/24</code> ネットワークのネットワークアドレスです。<br>
   このアドレスは、ネットワーク内のすべてのデバイスが属する共通の識別子となります。</p>

  <p>ホストアドレスは、ネットワーク内の個々のデバイス（ホスト）を識別するためのアドレスです。<br>
   例えば、<code>192.168.1.10</code> は、<code>192.168.1.0/24</code> ネットワーク内の特定のデバイスのホストアドレスです。<br>
   ホストアドレスは、ネットワークアドレスとサブネットマスクを組み合わせて決定されます。</p>

  <p>CIDR（Classless Inter-Domain Routing）表記は、IPアドレスとサブネットマスクを簡潔に表現する方法です。<br>
   例えば、<code>192.168.1.0/24</code> は、IPアドレス <code>192.168.1.0</code> とサブネットマスク <code>255.255.255.0</code>
   を表します。<br>
   <code>/24</code> は、ネットワーク部分が24ビットであることを示しています。
  </p>

  <p>サブネットは、大きなネットワークを小さなネットワークに分割するための方法です。<br>
   その結果、ネットワークの管理が容易になり、効率的なIPアドレスの利用が可能になります。<br>
   例えば、<code>192.168.1.0/24</code> ネットワークを <code>192.168.1.0/26</code> と <code>192.168.1.64/26</code>
   の2つのサブネットに分割することができます。</p>

  <p>DMZ（Demilitarized Zone）は、内部ネットワークと外部ネットワーク（インターネット）の間に配置される中間ネットワークです。<br>
   DMZに配置されたサーバーは、外部からアクセス可能でありながら、内部ネットワークへの直接アクセスを防ぐ役割を果たします。<br>
   このため、セキュリティが強化されます。</p>


  <!-- ●ここから人間用のフッター● -->
  <hr id="feinhr">
  <div class="spacer"></div>

  <section class="sitemap">
   <h2 class="sitemap_heading">サイトマップ</h2>
   <p><a href="/another-eden/anaden_sitemap.html"><i class="fas fa-sitemap"></i>
     アナザーエデン関連ページ・サイトマップ</a></p>
   <p>アナザーエデンの強敵戦やストーリーコンテンツのリスト、お勧めバッジなどを掲載したコーナーです。<br>
    期間限定のない普通のRPGですので、初心者でも安心して続けていけるゲームとなっています。<br>
    もっとも重要なグラスタについては、場所別に網羅した表があります。</p>


   <div class="spacer"></div>
   <p><a href="/contents/site_create.html"><i class="fas fa-sitemap"></i>
     個人サイトのホスティングとコンテンツ作成</a></p>
   <p>個人でウェブサイトを作るにはどうすればいいか。<br>
    HTML・CSS・JavaScriptの書き方はもちろん、無料かつ広告なしでホームページを作る方法を掲載したコーナーです。<br>
    Webデザインやレイアウトについても書いてあります。</p>
   <div class="spacer"></div>
   <p><a href="/fish/fish_sitemap.html"><i class="fas fa-sitemap"></i>魚釣りなどアウトドアのエリア</a></p>
   <p>ゲームとパソコンだけじゃなく、アウトドアも趣味なんです。<br>
    このコーナーでは魚釣りの記録とか、魚料理のレシピ、はたまたサイクリングなどなど。<br>
    アウトドアに関連するコンテンツが詰め込まれています。</p>

  </section>

  <!-- ページ上部へ戻るボタン -->
  <button id="scrollToTopBtn" onclick="scrollToTop()">ページ上部へ戻る</button>
  <script src="/script/feinScroll.js"></script>

  <div class="spacer"></div>

  <footer>
   <!--common google digital leader-->

   <div id="commongdl"></div>
   <script src="/externalization/common.js"></script>

   <div class="spacer"></div>

   <!--w3cバリデーターに合格していることを示す-->
   <div class="w3ccheck">
    <a href="https://validator.w3.org/nu/?doc=https://fein-sites-dev1.ew.r.appspot.com/contents/appengine.html">
     <img src="/image/HTML5_Logo_64.png" alt="Valid HTML5" height="31" style="width: auto;">
    </a>
    <a href="https://validator.w3.org/nu/?doc=https://fein-sites-dev1.ew.r.appspot.com/css/style.css">
     <img style="border:0;width:88px;height:31px" src="/image/vcss-blue.png" alt="正当なCSSです!">
    </a>
   </div>
   <!--w3cバリデーターに合格していることを示す-->

   <div class="spacer"></div>
   <p class="portal" id="updated-date">この <a href="https://fein-sites-dev1.ew.r.appspot.com/">fein's personal
     site</a> は、2023/7/4に開設された <a href="https://sites.google.com/view/feins-portal/">fein's portal</a>
    を母体として、yyyy/mm/ddに至るまで更新し続けられています。</p>
   <script>
    document.addEventListener('DOMContentLoaded', function () {
     const today = new Date();
     const year = today.getFullYear();
     const month = String(today.getMonth() + 1).padStart(2, '0');
     const day = String(today.getDate()).padStart(2, '0');
     const dateElement = document.getElementById('updated-date');
     dateElement.innerHTML = `この <a href="https://fein-sites-dev1.ew.r.appspot.com/">fein's personal site</a> は、2023/7/4に開設された <a href="https://sites.google.com/view/feins-portal/">fein's portal</a> を母体として、${year}/${month}/${day}に至るまで更新し続けられています。`;
    });
   </script>

  </footer>

 </div><!--レスポンシブデザイン-->

 <script src="/script/feinheadline1.js"></script><!--見出しの自動生成-->

 <!-- ●ここまで人間用のフッター。直下でbodyを閉める● -->
</body>

</html>
